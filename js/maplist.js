// Generated by CoffeeScript 1.5.0
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  (function($) {
    var Data, MapList, Parser, log;
    log = _.bind(console.log, console);
    MapList = (function() {

      MapList.prototype["default"] = function() {
        return {
          center: new google.maps.LatLng(35, 135),
          zoom: 4,
          mapTypeId: google.maps.MapTypeId.ROADMAP,
          data: [],
          mapSelector: '#map_canvas',
          listSelector: '#list',
          listTemplate: null,
          infoTemplate: null,
          listToMarkerSelector: '.open-info',
          genreAlias: 'genre',
          genreContainerSelector: '#genre',
          genreSelector: '',
          firstGenre: '__all__'
        };
      };

      function MapList(options) {
        this["default"] = __bind(this["default"], this);
        var _this = this;
        _.bindAll(this);
        this.options = _.extend({}, _(this).result('default'), options);
        this.makeMap();
        this.entries = new Data(_.clone(this.options));
        this.entries.then(function() {
          return _this.build(_this.options.firstGenre);
        });
      }

      MapList.prototype.build = function(genreId) {
        var _this = this;
        return this.entries.filterdThen(genreId, function(usingEntries) {
          var entry, info, listElem, marker, _i, _len, _ref, _ref1, _results;
          _this.usingEntries = usingEntries;
          _ref = _this.usingEntries;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            entry = _ref[_i];
            _ref1 = _this.getEntryData(entry), info = _ref1[0], marker = _ref1[1], listElem = _ref1[2];
            _results.push(marker.setMap(_this.map));
          }
          return _results;
        });
      };

      MapList.prototype.clear = function() {};

      MapList.prototype.rebuild = function(genreId) {
        this.clear();
        return this.build(genreId);
      };

      MapList.prototype.makeMap = function() {
        var canvas, mapOptions;
        mapOptions = _(this.options).clone();
        canvas = $(this.options.mapSelector).get(0);
        return this.map = new google.maps.Map(canvas, mapOptions);
      };

      MapList.prototype.getEntryData = function(entry) {
        var info, listElem, marker, _ref, _ref1, _ref2;
        info = (_ref = entry.__info) != null ? _ref : entry.__info = this.makeInfo(entry);
        marker = (_ref1 = entry.__marker) != null ? _ref1 : entry.__marker = this.makeMarker(entry, info);
        listElem = (_ref2 = entry.__listElem) != null ? _ref2 : entry.__listElem = this.makeListElem(entry);
        return [info, marker, listElem];
      };

      MapList.prototype.makeInfo = function(entry) {
        var $tmpl, content, info,
          _this = this;
        $tmpl = this.options.infoTemplate;
        if ($tmpl != null) {
          content = $($tmpl.tmpl(entry)).html();
          info = new google.maps.InfoWindow({
            content: content
          });
          google.maps.event.addListener(info, 'closeclick', function() {
            return _this.openInfo = null;
          });
          return info;
        }
      };

      MapList.prototype.makeMarker = function(entry, info) {
        var marker, position,
          _this = this;
        position = new google.maps.LatLng(entry.lat, entry.lng);
        marker = new google.maps.Marker({
          position: position,
          icon: entry.icon
        });
        if (info) {
          google.maps.event.addListener(marker, 'click', function() {
            if (_this.openInfo != null) {
              _this.openInfo.close();
            }
            info.open(_this.map, marker);
            return _this.openInfo = info;
          });
        }
        return marker;
      };

      MapList.prototype.makeListElem = function() {};

      return MapList;

    })();
    Data = (function() {

      function Data(options) {
        var parser;
        this.options = options;
        _.bindAll(this);
        parser = new Parser(_.clone(this.options));
        this.options = _.extend({
          parse: parser.parse
        }, this.options);
        this.entries = this._makeEntries();
      }

      Data.prototype.then = function(done, fail) {
        return this.entries.then(done, fail);
      };

      Data.prototype.filterdThen = function(genreId, done, fail) {
        var _this = this;
        return this.entries.then(function(entries) {
          return done(_this._filterdEntries(genreId, entries));
        }, function(e) {
          return fail(e);
        });
      };

      Data.prototype._makeEntries = function() {
        var data, dfd,
          _this = this;
        dfd = new $.Deferred;
        data = this.options.data;
        if (_.isArray(data)) {
          dfd.resolve(data);
        } else if (_.isString(data)) {
          $.ajax({
            url: data
          }).done(function(data) {
            return dfd.resolve(_this.options.parse(data));
          }).fail(function() {
            return dfd.reject();
          });
        } else {
          dfd.reject();
        }
        return dfd.promise();
      };

      Data.prototype._filterdEntries = function(genreId, entries) {
        var alias, entry, _i, _len, _results;
        if (genreId === "__all__") {
          return entries;
        } else {
          alias = this.options.genreAlias;
          _results = [];
          for (_i = 0, _len = entries.length; _i < _len; _i++) {
            entry = entries[_i];
            if (entry[alias] === genreId) {
              _results.push(entry);
            }
          }
          return _results;
        }
      };

      return Data;

    })();
    Parser = (function() {

      function Parser(options) {
        this.options = options;
        _.bindAll(this);
      }

      Parser.prototype.parse = function(data) {
        if ($.isXMLDoc(data)) {
          return this._parseForXML(data);
        } else if (_.isObject(data)) {
          return this._parseForObject(data);
        } else {
          return data;
        }
      };

      Parser.prototype._parseForXML = function(data) {
        var $root, alias,
          _this = this;
        $root = $(">*:first", data);
        alias = this.options.genreAlias;
        return $.map($root.find(">" + alias), function(genre) {
          var $genre;
          $genre = $(genre);
          genre = {
            "icon": $genre.attr("icon")
          };
          genre["" + alias] = $genre.attr("id");
          genre["" + alias + "Name"] = $genre.attr("name");
          return $.map($genre.find(">place"), function(place) {
            var $place, position, res;
            $place = $(place);
            res = {};
            $place.children().each(function(idx, elem) {
              return res[elem.nodeName] = $(elem).text();
            });
            position = {
              lat: $place.attr('latitude'),
              lng: $place.attr('longitude')
            };
            return _.extend({}, genre, position, res);
          });
        });
      };

      Parser.prototype._parseForObject = function(data) {
        return data;
      };

      return Parser;

    })();
    return window.MapList = MapList;
  })(jQuery);

}).call(this);
